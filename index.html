/* Mini RPG – single-file JavaScript
   - Builds UI (HUD, map, dialog, buttons) and runs simple gameplay.
   - Controls: Arrow keys / WASD to move. Space or Attack to hit.
   - Stand next to the slime (up/down/left/right adjacent) to attack.
*/

(function () {
  // --- Helpers ---------------------------------------------------------------
  const $ = (sel, el = document) => el.querySelector(sel);
  const el = (tag, props = {}, ...children) => {
    const n = document.createElement(tag);
    Object.assign(n, props);
    for (const c of children) n.append(c);
    return n;
  };
  const css = (node, map) => Object.entries(map).forEach(([k, v]) => node.style.setProperty(k, v));

  // --- Game config -----------------------------------------------------------
  const TILE = 32;
  const COLS = 12;
  const ROWS = 8;

  // 0=grass 1=path 2=water 3=wall
  const mapData = [
    [0,0,1,1,0,0,2,2,0,0,0,0],
    [0,0,1,1,0,0,2,2,0,0,0,0],
    [0,0,1,1,0,0,0,0,0,3,3,0],
    [0,0,0,0,0,1,1,1,0,3,0,0],
    [2,2,0,0,0,1,0,1,0,3,0,0],
    [2,2,0,3,0,1,0,1,0,0,0,0],
    [0,0,0,3,0,1,1,1,0,0,0,0],
    [0,0,0,3,0,0,0,0,0,0,0,0],
  ];
  const blocks = new Set([2,3]); // cannot walk on water/wall

  // --- Root & basic styles (keep lightweight) -------------------------------
  const root = el('div', { className: 'game-root' });
  document.body.replaceChildren(root);
  document.title = 'TinyQuest JS';

  const baseStyle = document.createElement('style');
  baseStyle.textContent = `
    :root{
      --bg:#0b0e12;--panel:#121820;--panel2:#0e131a;--border:#233041;
      --text:#e6edf3;--muted:#9aa4af;--accent:#8be9fd;--warn:#f1fa8c;--danger:#ff5555;
      --hp:100;--hp-max:100;--mp:50;--mp-max:50;--xp:0;--xp-max:100;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:#0b0e12;color:var(--text);font:12px/1.45 ui-monospace, monospace}
    .wrap{min-height:100vh;padding:16px;display:grid;gap:12px;
      grid-template-columns:240px 1fr 260px;grid-template-rows:auto 1fr auto}
    .panel{background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:2px solid var(--border);border-radius:10px;box-shadow:inset 0 0 0 3px #000, 0 4px 0 #0007;padding:12px}
    .hud{grid-column:1/-1;display:grid;grid-template-columns:360px 1fr 260px;gap:12px;align-items:center}
    .brand{color:var(--accent);font-weight:bold}
    .stat-row{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center}
    .stat-label{color:var(--muted);font-size:10px}
    .value-chip{background:#0b0f16;border:2px solid var(--border);padding:6px 8px;border-radius:8px;min-width:80px;text-align:center}
    .bar{--value:0;--max:100;--color:#4caf50;position:relative;width:100%;height:14px;border:2px solid var(--border);
      border-radius:7px;background:#1a2230;overflow:hidden}
    .bar i{display:block;height:100%;width:calc((var(--value)/var(--max))*100%);
      background:linear-gradient(90deg,rgba(255,255,255,.12) 0, transparent 20%), var(--color);
      background-size:16px 100%, auto;animation:flow 1s linear infinite}
    @keyframes flow{to{background-position:-16px 0, 0 0}}
    .hp{--value:var(--hp);--max:var(--hp-max);--color:linear-gradient(90deg,#f66,#d22)}
    .mp{--value:var(--mp);--max:var(--mp-max);--color:linear-gradient(90deg,#5aa9ff,#2d67ff)}
    .xp{--value:var(--xp);--max:var(--xp-max);--color:linear-gradient(90deg,#7aff9c,#29c76b)}
    .inv-grid{--cell:48px;display:grid;grid-template-columns:repeat(4,var(--cell));grid-auto-rows:var(--cell);gap:8px}
    .slot{position:relative;background:#0b1018;border:2px solid var(--border);border-radius:8px;box-shadow:inset 0 0 0 3px #000;display:grid;place-items:center}
    .slot .qty{position:absolute;bottom:4px;right:6px;font-size:10px;color:var(--muted)}
    .map{position:relative;width:${COLS*TILE}px;height:${ROWS*TILE}px;background:#0c1219;border:2px solid var(--border);border-radius:10px;box-shadow:inset 0 0 0 3px #000,0 4px 0 #0007;overflow:hidden}
    .tiles{display:grid;grid-template-columns:repeat(${COLS},${TILE}px);grid-auto-rows:${TILE}px}
    .tile{width:${TILE}px;height:${TILE}px}
    .grass{background:#1c4020}.path{background:#6b5b43}.water{background:#0d2c59}.wall{background:#2a2f3a}
    .sprite{position:absolute;width:${TILE}px;height:${TILE}px;image-rendering:pixelated}
    .player{background:#3ec1d3}.npc{background:#f6ab6c}
    .btn{display:inline-block;padding:10px 12px;border-radius:10px;border:2px solid var(--border);
      background:linear-gradient(#1a2330,#121a25);box-shadow:inset 0 0 0 3px #000, 0 4px 0 #0007;cursor:pointer;user-select:none}
    .btn:active{transform:translateY(2px);box-shadow:inset 0 0 0 3px #000,0 2px 0 #0006}
    .dialog{position:relative;min-height:80px;line-height:1.6}
    .dialog .name{position:absolute;top:-12px;left:12px;padding:2px 6px;font-size:10px;background:#0e1520;border:2px solid var(--border);border-radius:6px}
    .log{font-size:10px;color:var(--muted);height:120px;overflow:auto}
    .toast{position:absolute;pointer-events:none;transform:translate(-50%,-50%);white-space:nowrap;text-shadow:0 2px 0 #000;animation:pop .8s ease-out forwards}
    .toast.hit{color:#ff5555;font-size:16px}.toast.crit{color:#ffb86c;font-size:18px}
    @keyframes pop{0%{opacity:0;transform:translate(-50%,-10%) scale(.9)}10%{opacity:1;transform:translate(-50%,-20%) scale(1.05)}100%{opacity:0;transform:translate(-50%,-80%) scale(1)}}
    .footer{grid-column:1/-1;display:flex;justify-content:space-between;color:var(--muted);font-size:10px}
    @media(max-width:1100px){.wrap{grid-template-columns:1fr;grid-template-rows:auto auto auto auto}.map{margin-inline:auto}}
  `;
  document.head.append(baseStyle);

  // --- Build UI --------------------------------------------------------------
  const wrap = el('div', { className: 'wrap' });

  // HUD
  const hud = el('div', { className: 'panel hud' },
    el('div', { className: 'brand' }, '★ TinyQuest (JS)'),
    (() => {
      const box = el('div', { className: 'hud-center' });
      box.append(
        statRow('HP', 'hp', () => `${state.player.hp}/${state.player.hpMax}`),
        statRow('MP', 'mp', () => `${state.player.mp}/${state.player.mpMax}`),
        statRow('XP', 'xp', () => `Lv ${state.player.level}`)
      );
      return box;
    })(),
    el('div', { className: 'value-chip', id: 'goldChip' }, 'Gold: 0')
  );

  // Left: Inventory
  const left = el('aside', { className: 'panel' },
    el('h3', { style: 'margin:0 0 10px 0' }, 'Inventory'),
    (() => {
      const g = el('div', { className: 'inv-grid', id: 'inv' });
      for (let i = 0; i < 8; i++) g.append(el('div', { className: 'slot' }));
      return g;
    })(),
    el('div', { style: 'margin-top:12px;display:grid;gap:8px' },
      el('div', { className: 'slot' }, 'Potion', el('span', { className: 'qty', id: 'potionQty' }, '1'))
    )
  );

  // Center: Map
  const map = el('div', { className: 'panel', style: 'display:grid;place-items:center' },
    buildMap()
  );

  // Right: Dialog + Actions
  const right = el('aside', { className: 'panel' },
    (() => {
      const d = el('div', { className: 'dialog' },
        el('div', { className: 'name' }, 'Guide'),
        el('div', { className: 'text', id: 'dialogText' }, 'Welcome, adventurer. Stand next to the slime and press Attack!')
      );
      return d;
    })(),
    el('div', { style: 'margin-top:12px;display:flex;gap:8px;flex-wrap:wrap' },
      el('button', { className: 'btn', id: 'attackBtn' }, 'Attack'),
      el('button', { className: 'btn', id: 'defendBtn' }, 'Defend'),
      el('button', { className: 'btn', id: 'itemBtn' }, 'Use Potion')
    ),
    el('div', { className: 'log', id: 'log' })
  );

  // Footer
  const foot = el('div', { className: 'footer' },
    el('div', {}, 'Tips: Move with Arrow keys/WASD. Space to attack.'),
    el('div', {}, '© TinyQuest')
  );

  wrap.append(hud, left, map, right, foot);
  root.append(wrap);

  // --- Game state ------------------------------------------------------------
  const state = {
    player: { x: 3, y: 3, hp: 86, hpMax: 100, mp: 42, mpMax: 60, level: 1, xp: 30, gold: 0, potions: 1 },
    slime:  { x: 6, y: 4, hp: 40, alive: true },
  };

  // Sprites
  const mapEl = $('.map');
  const playerEl = el('div', { className: 'sprite player', id: 'player' });
  const slimeEl  = el('div', { className: 'sprite npc', id: 'slime' });
  mapEl.append(playerEl, slimeEl);

  // Initial draw
  syncBars();
  placeSprite(playerEl, state.player.x, state.player.y);
  placeSprite(slimeEl, state.slime.x, state.slime.y);
  updateGold();
  log('You entered the glade.');

  // --- Controls --------------------------------------------------------------
  window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    const moveKeys = ['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'];
    if (moveKeys.includes(e.key.toLowerCase())) e.preventDefault();

    if (['w','arrowup'].includes(key)) tryMove(0, -1);
    if (['s','arrowdown'].includes(key)) tryMove(0,  1);
    if (['a','arrowleft'].includes(key)) tryMove(-1, 0);
    if (['d','arrowright'].includes(key)) tryMove(1,  0);
    if (key === ' ') doAttack();
  });

  $('#attackBtn').addEventListener('click', doAttack);
  $('#defendBtn').addEventListener('click', () => {
    speak('Guide', 'Defending reduces next damage by half.');
    log('You brace yourself.');
    state._defending = true;
  });
  $('#itemBtn').addEventListener('click', () => {
    if (state.player.potions > 0 && state.player.hp < state.player.hpMax) {
      state.player.potions--;
      const heal = Math.min(25, state.player.hpMax - state.player.hp);
      state.player.hp += heal;
      $('#potionQty').textContent = String(state.player.potions);
      syncBars();
      toast(playerEl, `+${heal}`, 'crit');
      log(`You used a Potion and healed ${heal}.`);
    } else {
      speak('Guide', 'No need or no potions left.');
    }
  });

  // --- Functions -------------------------------------------------------------
  function buildMap() {
    const wrap = el('div', { className: 'map' });
    const tiles = el('div', { className: 'tiles' });
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const t = mapData[y][x];
        const c = ['grass','path','water','wall'][t] || 'grass';
        tiles.append(el('div', { className: `tile ${c}` }));
      }
    }
    wrap.append(tiles);
    return wrap;
  }

  function placeSprite(node, x, y) {
    node.style.transform = `translate(${x*TILE}px, ${y*TILE}px)`;
  }

  function inBounds(x,y){ return x>=0 && y>=0 && x<COLS && y<ROWS; }
  function isWalkable(x,y){
    if (!inBounds(x,y)) return false;
    return !blocks.has(mapData[y][x]);
  }

  function tryMove(dx, dy) {
    const nx = state.player.x + dx, ny = state.player.y + dy;
    if (!isWalkable(nx, ny)) { speak('Guide', 'You can’t go there.'); return; }
    state.player.x = nx; state.player.y = ny;
    placeSprite(playerEl, nx, ny);
    // Random coin find
    if (Math.random() < 0.08) {
      state.player.gold += 1;
      updateGold();
      log('You found 1 gold.');
    }
    // Slime may step closer a bit
    if (state.slime.alive && Math.random() < 0.5) slimeStepTowardPlayer();
  }

  function adjacent(ax, ay, bx, by) {
    return (Math.abs(ax-bx) + Math.abs(ay-by)) === 1;
  }

  function doAttack() {
    if (!state.slime.alive) { speak('Guide','The slime is already defeated.'); return; }
    if (!adjacent(state.player.x, state.player.y, state.slime.x, state.slime.y)) {
      speak('Guide','Get next to the slime to attack.'); return;
    }
    const dmg = roll(6, 10);
    state.slime.hp -= dmg;
    toast(slimeEl, `-${dmg}`, 'hit');
    log(`You hit Slime for ${dmg}.`);
    if (state.slime.hp <= 0) {
      state.slime.alive = false;
      slimeEl.style.opacity = 0.5;
      speak('Guide', 'Well done! The slime dissolves. You gain 20 XP and 5 gold.');
      state.player.xp += 20; state.player.gold += 5; updateGold();
      levelCheck();
      return;
    }
    // Slime turn
    setTimeout(slimeAttack, 300);
  }

  function slimeAttack() {
    if (!state.slime.alive) return;
    // Move toward if not adjacent
    if (!adjacent(state.player.x, state.player.y, state.slime.x, state.slime.y)) {
      slimeStepTowardPlayer();
      return;
    }
    let dmg = roll(3,7);
    if (state._defending) { dmg = Math.ceil(dmg/2); state._defending = false; }
    state.player.hp = Math.max(0, state.player.hp - dmg);
    toast(playerEl, `-${dmg}`, 'hit');
    log(`Slime splashes you for ${dmg}.`);
    syncBars();
    if (state.player.hp <= 0) {
      speak('Guide', 'You fainted! Refresh to try again.');
      disableControls();
    }
  }

  function slimeStepTowardPlayer() {
    const { x:px, y:py } = state.player;
    const { x:sx, y:sy } = state.slime;
    const dx = Math.sign(px - sx), dy = Math.sign(py - sy);
    const try1 = Math.random() < 0.5 ? [sx+dx, sy] : [sx, sy+dy];
    const try2 = Math.random() < 0.5 ? [sx, sy+dy] : [sx+dx, sy];
    if (isWalkable(...try1)) { state.slime.x = try1[0]; state.slime.y = try1[1]; }
    else if (isWalkable(...try2)) { state.slime.x = try2[0]; state.slime.y = try2[1]; }
    placeSprite(slimeEl, state.slime.x, state.slime.y);
  }

  function roll(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

  function syncBars() {
    document.documentElement.style.setProperty('--hp', state.player.hp);
    document.documentElement.style.setProperty('--hp-max', state.player.hpMax);
    document.documentElement.style.setProperty('--mp', state.player.mp);
    document.documentElement.style.setProperty('--mp-max', state.player.mpMax);
    document.documentElement.style.setProperty('--xp', state.player.xp);
    document.documentElement.style.setProperty('--xp-max', 100);
    $('#hpVal').textContent = `${state.player.hp}/${state.player.hpMax}`;
    $('#mpVal').textContent = `${state.player.mp}/${state.player.mpMax}`;
    $('#xpVal').textContent = `Lv ${state.player.level}`;
  }

  function levelCheck() {
    while (state.player.xp >= 100) {
      state.player.xp -= 100;
      state.player.level++;
      state.player.hpMax += 10;
      state.player.hp = state.player.hpMax;
      state.player.mpMax += 5;
      state.player.mp = state.player.mpMax;
      log(`You reached Level ${state.player.level}!`);
      syncBars();
    }
  }

  function speak(name, text) {
    $('#dialogText').textContent = text;
  }

  function log(msg) {
    const L = $('#log');
    L.innerHTML += `${escapeHtml(msg)}<br/>`;
    L.scrollTop = L.scrollHeight;
  }

  function updateGold() {
    $('#goldChip').textContent = `Gold: ${state.player.gold}`;
  }

  function toast(anchorEl, text, kind='hit') {
    const t = el('div', { className: `toast ${kind}` }, text);
    const r = anchorEl.getBoundingClientRect();
    const mp = mapEl.getBoundingClientRect();
    t.style.left = `${(r.left + r.right)/2 - mp.left}px`;
    t.style.top  = `${(r.top + r.bottom)/2 - mp.top}px`;
    mapEl.append(t);
    setTimeout(() => t.remove(), 800);
  }

  function escapeHtml(s){ return s.replace(/[&<>"']/g,(c)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

  function disableControls() {
    window.onkeydown = null;
    $('#attackBtn').disabled = true;
    $('#defendBtn').disabled = true;
    $('#itemBtn').disabled = true;
  }

  // --- HUD rows (built with live span targets) -------------------------------
  function statRow(label, cls, valueFn) {
    const row = el('div', { className: 'stat-row' },
      el('span', { className: 'stat-label' }, label),
      (() => {
        const b = el('div', { className: `bar ${cls}` });
        b.append(el('i'));
        return b;
      })(),
      el('span', { className: 'value-chip', id: `${cls}Val` }, valueFn())
    );
    return row;
  }

  // --- finalize --------------------------------------------------------------
  // Insert HUD bars with initial values formatted (after DOM present)
  syncBars();

})();
